<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from first.wpi.edu/FRC/roborio/release/docs/cpp/classllvm_1_1StringRef.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Jan 2016 07:54:36 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>WPILibC++: llvm::StringRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">WPILibC++
   &#160;<span id="projectnumber">unspecified</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index-2.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classllvm_1_1StringRef.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classllvm_1_1StringRef-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llvm::StringRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a> - Represent a constant reference to a string, i.e.  
 <a href="classllvm_1_1StringRef.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StringRef_8h_source.html">StringRef.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7bf566fe5a23be3257375b0cf7f7c101"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf566fe5a23be3257375b0cf7f7c101"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a7bf566fe5a23be3257375b0cf7f7c101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b561890c89b3805eb29856ce78f862"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68b561890c89b3805eb29856ce78f862"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a68b561890c89b3805eb29856ce78f862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3a40d51d77f1faf56c40460033d0a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f3a40d51d77f1faf56c40460033d0a9"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a0f3a40d51d77f1faf56c40460033d0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a0f1746161a67c7b6d85e8c6a6cca62cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1746161a67c7b6d85e8c6a6cca62cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a0f1746161a67c7b6d85e8c6a6cca62cd">StringRef</a> ()</td></tr>
<tr class="memdesc:a0f1746161a67c7b6d85e8c6a6cca62cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty string ref. <br/></td></tr>
<tr class="separator:a0f1746161a67c7b6d85e8c6a6cca62cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17da9958074a0ab57c90c7da4947d78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa17da9958074a0ab57c90c7da4947d78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aa17da9958074a0ab57c90c7da4947d78">StringRef</a> (const char *Str)</td></tr>
<tr class="memdesc:aa17da9958074a0ab57c90c7da4947d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a cstring. <br/></td></tr>
<tr class="separator:aa17da9958074a0ab57c90c7da4947d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd30c854f2417bc5f407d309f4d230e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebd30c854f2417bc5f407d309f4d230e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aebd30c854f2417bc5f407d309f4d230e">StringRef</a> (const char *<a class="el" href="classllvm_1_1StringRef.html#a7d9b88d042ae1da8afd5509875c90a04">data</a>, size_t length)</td></tr>
<tr class="memdesc:aebd30c854f2417bc5f407d309f4d230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from a pointer and length. <br/></td></tr>
<tr class="separator:aebd30c854f2417bc5f407d309f4d230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcb6e1997e871ac41f506eff6bdc051"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebcb6e1997e871ac41f506eff6bdc051"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aebcb6e1997e871ac41f506eff6bdc051">StringRef</a> (const std::string &amp;Str)</td></tr>
<tr class="memdesc:aebcb6e1997e871ac41f506eff6bdc051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string ref from an std::string. <br/></td></tr>
<tr class="separator:aebcb6e1997e871ac41f506eff6bdc051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a4a0abf8eb4fa5989df63172649cba99f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a0abf8eb4fa5989df63172649cba99f"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:a4a0abf8eb4fa5989df63172649cba99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e277b660236bb0318b61ab9cdf60dc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e277b660236bb0318b61ab9cdf60dc7"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a9e277b660236bb0318b61ab9cdf60dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0766b7dc32f7e9b640ec8e4a3c8ea45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0766b7dc32f7e9b640ec8e4a3c8ea45"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_begin</b> () const </td></tr>
<tr class="separator:ab0766b7dc32f7e9b640ec8e4a3c8ea45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c867f8155b53a1d00d13c972ee1ce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6c867f8155b53a1d00d13c972ee1ce5"></a>
const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_end</b> () const </td></tr>
<tr class="separator:aa6c867f8155b53a1d00d13c972ee1ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Operations</div></td></tr>
<tr class="memitem:a7d9b88d042ae1da8afd5509875c90a04"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a7d9b88d042ae1da8afd5509875c90a04">data</a> () const </td></tr>
<tr class="memdesc:a7d9b88d042ae1da8afd5509875c90a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">data - Get a pointer to the start of the string (which may not be null terminated).  <a href="#a7d9b88d042ae1da8afd5509875c90a04">More...</a><br/></td></tr>
<tr class="separator:a7d9b88d042ae1da8afd5509875c90a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e292682516000f8b472f4510a2acf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e292682516000f8b472f4510a2acf7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#ad7e292682516000f8b472f4510a2acf7">empty</a> () const </td></tr>
<tr class="memdesc:ad7e292682516000f8b472f4510a2acf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty - Check if the string is empty. <br/></td></tr>
<tr class="separator:ad7e292682516000f8b472f4510a2acf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68d5ebdb576d7481ea2766151b875d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af68d5ebdb576d7481ea2766151b875d4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4">size</a> () const </td></tr>
<tr class="memdesc:af68d5ebdb576d7481ea2766151b875d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">size - Get the string size. <br/></td></tr>
<tr class="separator:af68d5ebdb576d7481ea2766151b875d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b3826e64820f25495bb882b906cc0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b3826e64820f25495bb882b906cc0d"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a05b3826e64820f25495bb882b906cc0d">front</a> () const </td></tr>
<tr class="memdesc:a05b3826e64820f25495bb882b906cc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">front - Get the first character in the string. <br/></td></tr>
<tr class="separator:a05b3826e64820f25495bb882b906cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9904c6e695f8ac00208d00663040c173"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9904c6e695f8ac00208d00663040c173"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a9904c6e695f8ac00208d00663040c173">back</a> () const </td></tr>
<tr class="memdesc:a9904c6e695f8ac00208d00663040c173"><td class="mdescLeft">&#160;</td><td class="mdescRight">back - Get the last character in the string. <br/></td></tr>
<tr class="separator:a9904c6e695f8ac00208d00663040c173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b7b81d4826db928760c7c4f1942032"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44b7b81d4826db928760c7c4f1942032"></a>
template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a44b7b81d4826db928760c7c4f1942032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (Allocator &amp;A) const </td></tr>
<tr class="separator:a44b7b81d4826db928760c7c4f1942032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c565e0d52fdd3b366971d07fa0c83c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a29c565e0d52fdd3b366971d07fa0c83c">equals</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:a29c565e0d52fdd3b366971d07fa0c83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals - Check for string equality, this is more efficient than <a class="el" href="classllvm_1_1StringRef.html#aaad2ceb595181c43b5969814345ab198" title="compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less tha...">compare()</a> when the relative ordering of inequal strings isn't needed.  <a href="#a29c565e0d52fdd3b366971d07fa0c83c">More...</a><br/></td></tr>
<tr class="separator:a29c565e0d52fdd3b366971d07fa0c83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91ec0c78e03404aedf982aefd69fff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab91ec0c78e03404aedf982aefd69fff5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#ab91ec0c78e03404aedf982aefd69fff5">equals_lower</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:ab91ec0c78e03404aedf982aefd69fff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals_lower - Check for string equality, ignoring case. <br/></td></tr>
<tr class="separator:ab91ec0c78e03404aedf982aefd69fff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad2ceb595181c43b5969814345ab198"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aaad2ceb595181c43b5969814345ab198">compare</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:aaad2ceb595181c43b5969814345ab198"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less than, equal to, or greater than the <code>RHS</code>.  <a href="#aaad2ceb595181c43b5969814345ab198">More...</a><br/></td></tr>
<tr class="separator:aaad2ceb595181c43b5969814345ab198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c93533914a679e39ceb1f2b6c4ee17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a18c93533914a679e39ceb1f2b6c4ee17">compare_lower</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:a18c93533914a679e39ceb1f2b6c4ee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_lower - Compare two strings, ignoring case.  <a href="#a18c93533914a679e39ceb1f2b6c4ee17">More...</a><br/></td></tr>
<tr class="separator:a18c93533914a679e39ceb1f2b6c4ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d9962fdd675f3ae6c0da806971c844"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a64d9962fdd675f3ae6c0da806971c844">compare_numeric</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> RHS) const </td></tr>
<tr class="memdesc:a64d9962fdd675f3ae6c0da806971c844"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare_numeric - Compare two strings, treating sequences of digits as numbers.  <a href="#a64d9962fdd675f3ae6c0da806971c844">More...</a><br/></td></tr>
<tr class="separator:a64d9962fdd675f3ae6c0da806971c844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02cb6f4884b5c788efb97b6741dccaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab02cb6f4884b5c788efb97b6741dccaf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#ab02cb6f4884b5c788efb97b6741dccaf">str</a> () const </td></tr>
<tr class="memdesc:ab02cb6f4884b5c788efb97b6741dccaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">str - Get the contents as an std::string. <br/></td></tr>
<tr class="separator:ab02cb6f4884b5c788efb97b6741dccaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6aa5b1d2c9f5aec91bc4b56fb17351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e6aa5b1d2c9f5aec91bc4b56fb17351"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>lower</b> () const </td></tr>
<tr class="separator:a8e6aa5b1d2c9f5aec91bc4b56fb17351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d344b462cf933c0a258c34267444086"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d344b462cf933c0a258c34267444086"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a0d344b462cf933c0a258c34267444086">upper</a> () const </td></tr>
<tr class="memdesc:a0d344b462cf933c0a258c34267444086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given ASCII string to uppercase. <br/></td></tr>
<tr class="separator:a0d344b462cf933c0a258c34267444086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator Overloads</div></td></tr>
<tr class="memitem:a39a201f01b39a1aff7161a3a6b2e39ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39a201f01b39a1aff7161a3a6b2e39ff"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t Index) const </td></tr>
<tr class="separator:a39a201f01b39a1aff7161a3a6b2e39ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Type Conversions</div></td></tr>
<tr class="memitem:ac93e7da6c52207ebf32ef2afb73b0c29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93e7da6c52207ebf32ef2afb73b0c29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator std::string</b> () const </td></tr>
<tr class="separator:ac93e7da6c52207ebf32ef2afb73b0c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Predicates</div></td></tr>
<tr class="memitem:a1a7bc4930b0396a67c30081f7cb30542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a7bc4930b0396a67c30081f7cb30542"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a1a7bc4930b0396a67c30081f7cb30542">startswith</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Prefix) const </td></tr>
<tr class="memdesc:a1a7bc4930b0396a67c30081f7cb30542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>. <br/></td></tr>
<tr class="separator:a1a7bc4930b0396a67c30081f7cb30542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab4ffd07d029ea99efb2a1ee4c8ca0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab4ffd07d029ea99efb2a1ee4c8ca0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a5ab4ffd07d029ea99efb2a1ee4c8ca0f">startswith_lower</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Prefix) const </td></tr>
<tr class="memdesc:a5ab4ffd07d029ea99efb2a1ee4c8ca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string starts with the given <code>Prefix</code>, ignoring case. <br/></td></tr>
<tr class="separator:a5ab4ffd07d029ea99efb2a1ee4c8ca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95e67973ed570584965dbbbd996d2f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa95e67973ed570584965dbbbd996d2f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aa95e67973ed570584965dbbbd996d2f0">endswith</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Suffix) const </td></tr>
<tr class="memdesc:aa95e67973ed570584965dbbbd996d2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>. <br/></td></tr>
<tr class="separator:aa95e67973ed570584965dbbbd996d2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b21f5c959ff46b6bb4f6e95c4f2753b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b21f5c959ff46b6bb4f6e95c4f2753b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a4b21f5c959ff46b6bb4f6e95c4f2753b">endswith_lower</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Suffix) const </td></tr>
<tr class="memdesc:a4b21f5c959ff46b6bb4f6e95c4f2753b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this string ends with the given <code>Suffix</code>, ignoring case. <br/></td></tr>
<tr class="separator:a4b21f5c959ff46b6bb4f6e95c4f2753b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Searching</div></td></tr>
<tr class="memitem:a421e16456fe6d7b71fb4af736194165c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a421e16456fe6d7b71fb4af736194165c">find</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:a421e16456fe6d7b71fb4af736194165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first character <code>C</code> in the string.  <a href="#a421e16456fe6d7b71fb4af736194165c">More...</a><br/></td></tr>
<tr class="separator:a421e16456fe6d7b71fb4af736194165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96985243e286d1d9c10028e7c2497c56"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a96985243e286d1d9c10028e7c2497c56">find</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Str, size_t From=0) const </td></tr>
<tr class="memdesc:a96985243e286d1d9c10028e7c2497c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the first string <code>Str</code> in the string.  <a href="#a96985243e286d1d9c10028e7c2497c56">More...</a><br/></td></tr>
<tr class="separator:a96985243e286d1d9c10028e7c2497c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87091ed60a621a3d430752da2996d27b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a87091ed60a621a3d430752da2996d27b">rfind</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:a87091ed60a621a3d430752da2996d27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last character <code>C</code> in the string.  <a href="#a87091ed60a621a3d430752da2996d27b">More...</a><br/></td></tr>
<tr class="separator:a87091ed60a621a3d430752da2996d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a01bee3e5396e08d70d28f2273749ee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a3a01bee3e5396e08d70d28f2273749ee">rfind</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Str) const </td></tr>
<tr class="memdesc:a3a01bee3e5396e08d70d28f2273749ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the last string <code>Str</code> in the string.  <a href="#a3a01bee3e5396e08d70d28f2273749ee">More...</a><br/></td></tr>
<tr class="separator:a3a01bee3e5396e08d70d28f2273749ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b5863f31e0a39c204f3460f9ddde75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a54b5863f31e0a39c204f3460f9ddde75">find_first_of</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:a54b5863f31e0a39c204f3460f9ddde75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is <code>C</code>, or npos if not found.  <a href="#a54b5863f31e0a39c204f3460f9ddde75">More...</a><br/></td></tr>
<tr class="separator:a54b5863f31e0a39c204f3460f9ddde75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b6861cb9a895bf41b8a4776d369223"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#ae1b6861cb9a895bf41b8a4776d369223">find_first_of</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars, size_t From=0) const </td></tr>
<tr class="memdesc:ae1b6861cb9a895bf41b8a4776d369223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is in <code>Chars</code>, or npos if not found.  <a href="#ae1b6861cb9a895bf41b8a4776d369223">More...</a><br/></td></tr>
<tr class="separator:ae1b6861cb9a895bf41b8a4776d369223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8a9dc13034dc6a31a5dea627190c88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#ace8a9dc13034dc6a31a5dea627190c88">find_first_not_of</a> (char C, size_t From=0) const </td></tr>
<tr class="memdesc:ace8a9dc13034dc6a31a5dea627190c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is not <code>C</code> or npos if not found.  <a href="#ace8a9dc13034dc6a31a5dea627190c88">More...</a><br/></td></tr>
<tr class="separator:ace8a9dc13034dc6a31a5dea627190c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777c832d1540b92bcff9c0570d161f90"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a777c832d1540b92bcff9c0570d161f90">find_first_not_of</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars, size_t From=0) const </td></tr>
<tr class="memdesc:a777c832d1540b92bcff9c0570d161f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found.  <a href="#a777c832d1540b92bcff9c0570d161f90">More...</a><br/></td></tr>
<tr class="separator:a777c832d1540b92bcff9c0570d161f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0038321ed1d841fe288aee1277cadb70"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a0038321ed1d841fe288aee1277cadb70">find_last_of</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:a0038321ed1d841fe288aee1277cadb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is <code>C</code>, or npos if not found.  <a href="#a0038321ed1d841fe288aee1277cadb70">More...</a><br/></td></tr>
<tr class="separator:a0038321ed1d841fe288aee1277cadb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5968a92ec57a8f6b7a68d177a647850"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#af5968a92ec57a8f6b7a68d177a647850">find_last_of</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars, size_t From=npos) const </td></tr>
<tr class="memdesc:af5968a92ec57a8f6b7a68d177a647850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is in <code>C</code>, or npos if not found.  <a href="#af5968a92ec57a8f6b7a68d177a647850">More...</a><br/></td></tr>
<tr class="separator:af5968a92ec57a8f6b7a68d177a647850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf350ba1b6968fc28d1d81173f7770f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aebf350ba1b6968fc28d1d81173f7770f">find_last_not_of</a> (char C, size_t From=npos) const </td></tr>
<tr class="memdesc:aebf350ba1b6968fc28d1d81173f7770f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is not <code>C</code>, or npos if not found.  <a href="#aebf350ba1b6968fc28d1d81173f7770f">More...</a><br/></td></tr>
<tr class="separator:aebf350ba1b6968fc28d1d81173f7770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95913dd81e5003546d086043e4a5aaa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#ad95913dd81e5003546d086043e4a5aaa">find_last_not_of</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars, size_t From=npos) const </td></tr>
<tr class="memdesc:ad95913dd81e5003546d086043e4a5aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last character in the string that is not in <code>Chars</code>, or npos if not found.  <a href="#ad95913dd81e5003546d086043e4a5aaa">More...</a><br/></td></tr>
<tr class="separator:ad95913dd81e5003546d086043e4a5aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Helpful Algorithms</div></td></tr>
<tr class="memitem:a96436c303562dc7d5839d1cdaa77dbc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96436c303562dc7d5839d1cdaa77dbc9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a96436c303562dc7d5839d1cdaa77dbc9">count</a> (char C) const </td></tr>
<tr class="memdesc:a96436c303562dc7d5839d1cdaa77dbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of occurrences of <code>C</code> in the string. <br/></td></tr>
<tr class="separator:a96436c303562dc7d5839d1cdaa77dbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0af4ae481a5a88c250d936aa86325b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a5e0af4ae481a5a88c250d936aa86325b">count</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Str) const </td></tr>
<tr class="memdesc:a5e0af4ae481a5a88c250d936aa86325b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of non-overlapped occurrences of <code>Str</code> in the string.  <a href="#a5e0af4ae481a5a88c250d936aa86325b">More...</a><br/></td></tr>
<tr class="separator:a5e0af4ae481a5a88c250d936aa86325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672503b088f3061a06a578586d3e0427"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a672503b088f3061a06a578586d3e0427"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::numeric_limits&lt; T &gt;<br class="typebreak"/>
::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a672503b088f3061a06a578586d3e0427">getAsInteger</a> (unsigned Radix, T &amp;Result) const </td></tr>
<tr class="memdesc:a672503b088f3061a06a578586d3e0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current string as an integer of the specified radix.  <a href="#a672503b088f3061a06a578586d3e0427">More...</a><br/></td></tr>
<tr class="separator:a672503b088f3061a06a578586d3e0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b094a9185a78344b4fab4674e3fb318"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b094a9185a78344b4fab4674e3fb318"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b094a9185a78344b4fab4674e3fb318"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt;!std::numeric_limits&lt; T &gt;<br class="typebreak"/>
::is_signed, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getAsInteger</b> (unsigned Radix, T &amp;Result) const </td></tr>
<tr class="separator:a4b094a9185a78344b4fab4674e3fb318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Substring Operations</div></td></tr>
<tr class="memitem:a3d0712956e53687d1894ba17b84aeffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a3d0712956e53687d1894ba17b84aeffa">substr</a> (size_t Start, size_t N=npos) const </td></tr>
<tr class="memdesc:a3d0712956e53687d1894ba17b84aeffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the substring from [Start, Start + N).  <a href="#a3d0712956e53687d1894ba17b84aeffa">More...</a><br/></td></tr>
<tr class="separator:a3d0712956e53687d1894ba17b84aeffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ad0b412c2ed8e3c96befe511bdc1a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a34ad0b412c2ed8e3c96befe511bdc1a0">drop_front</a> (size_t N=1) const </td></tr>
<tr class="memdesc:a34ad0b412c2ed8e3c96befe511bdc1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a> equal to 'this' but with the first <code>N</code> elements dropped.  <a href="#a34ad0b412c2ed8e3c96befe511bdc1a0">More...</a><br/></td></tr>
<tr class="separator:a34ad0b412c2ed8e3c96befe511bdc1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb927d9c3777f22883b7a9e98dc20759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#adb927d9c3777f22883b7a9e98dc20759">drop_back</a> (size_t N=1) const </td></tr>
<tr class="memdesc:adb927d9c3777f22883b7a9e98dc20759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a> equal to 'this' but with the last <code>N</code> elements dropped.  <a href="#adb927d9c3777f22883b7a9e98dc20759">More...</a><br/></td></tr>
<tr class="separator:adb927d9c3777f22883b7a9e98dc20759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84945a8050d1449eb630a7a1622aa76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a84945a8050d1449eb630a7a1622aa76f">slice</a> (size_t Start, size_t End) const </td></tr>
<tr class="memdesc:a84945a8050d1449eb630a7a1622aa76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the substring from [Start, End).  <a href="#a84945a8050d1449eb630a7a1622aa76f">More...</a><br/></td></tr>
<tr class="separator:a84945a8050d1449eb630a7a1622aa76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcce769239a53df854d89c4e08d0b41"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1StringRef.html">StringRef</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a4bcce769239a53df854d89c4e08d0b41">split</a> (char Separator) const </td></tr>
<tr class="memdesc:a4bcce769239a53df854d89c4e08d0b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator character.  <a href="#a4bcce769239a53df854d89c4e08d0b41">More...</a><br/></td></tr>
<tr class="separator:a4bcce769239a53df854d89c4e08d0b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e27b6de2b079de64e3e1808d5e35ac"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1StringRef.html">StringRef</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#af7e27b6de2b079de64e3e1808d5e35ac">split</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Separator) const </td></tr>
<tr class="memdesc:af7e27b6de2b079de64e3e1808d5e35ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="#af7e27b6de2b079de64e3e1808d5e35ac">More...</a><br/></td></tr>
<tr class="separator:af7e27b6de2b079de64e3e1808d5e35ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754c526bdddebddbf5e27f067e9f07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aa754c526bdddebddbf5e27f067e9f07d">split</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &gt; &amp;A, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Separator, int MaxSplit=-1, bool KeepEmpty=true) const </td></tr>
<tr class="memdesc:aa754c526bdddebddbf5e27f067e9f07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into substrings around the occurrences of a separator string.  <a href="#aa754c526bdddebddbf5e27f067e9f07d">More...</a><br/></td></tr>
<tr class="separator:aa754c526bdddebddbf5e27f067e9f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47513446cbacaec202fcad44e553e3c1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classllvm_1_1StringRef.html">StringRef</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a47513446cbacaec202fcad44e553e3c1">rsplit</a> (char Separator) const </td></tr>
<tr class="memdesc:a47513446cbacaec202fcad44e553e3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the last occurrence of a separator character.  <a href="#a47513446cbacaec202fcad44e553e3c1">More...</a><br/></td></tr>
<tr class="separator:a47513446cbacaec202fcad44e553e3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b1141e695b117bb36a77961883893d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a44b1141e695b117bb36a77961883893d">ltrim</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const </td></tr>
<tr class="memdesc:a44b1141e695b117bb36a77961883893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the left removed.  <a href="#a44b1141e695b117bb36a77961883893d">More...</a><br/></td></tr>
<tr class="separator:a44b1141e695b117bb36a77961883893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067bebe85de2211b84ee087cfc7c7694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#a067bebe85de2211b84ee087cfc7c7694">rtrim</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const </td></tr>
<tr class="memdesc:a067bebe85de2211b84ee087cfc7c7694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the right removed.  <a href="#a067bebe85de2211b84ee087cfc7c7694">More...</a><br/></td></tr>
<tr class="separator:a067bebe85de2211b84ee087cfc7c7694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20b9ae7228d48ceb497bd69f20a838f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1StringRef.html#aa20b9ae7228d48ceb497bd69f20a838f">trim</a> (<a class="el" href="classllvm_1_1StringRef.html">StringRef</a> Chars=&quot; \t\n\v\f\r&quot;) const </td></tr>
<tr class="memdesc:aa20b9ae7228d48ceb497bd69f20a838f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string with consecutive characters in <code>Chars</code> starting from the left and right removed.  <a href="#aa20b9ae7228d48ceb497bd69f20a838f">More...</a><br/></td></tr>
<tr class="separator:aa20b9ae7228d48ceb497bd69f20a838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7414af479a1a88b0631120a4fc681e20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7414af479a1a88b0631120a4fc681e20"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>npos</b> = ~size_t(0)</td></tr>
<tr class="separator:a7414af479a1a88b0631120a4fc681e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a> - Represent a constant reference to a string, i.e. </p>
<p>a character array and a length, which need not be null terminated.</p>
<p>This class does not own the string data, it is expected to be used in situations where the character data resides in some other buffer, whose lifetime extends past that of the <a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a>. For this reason, it is not in general safe to store a <a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaad2ceb595181c43b5969814345ab198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int llvm::StringRef::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less than, equal to, or greater than the <code>RHS</code>. </p>

</div>
</div>
<a class="anchor" id="a18c93533914a679e39ceb1f2b6c4ee17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StringRef::compare_lower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare_lower - Compare two strings, ignoring case. </p>
<p>compare_lower - Compare strings, ignoring case. </p>

</div>
</div>
<a class="anchor" id="a64d9962fdd675f3ae6c0da806971c844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StringRef::compare_numeric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare_numeric - Compare two strings, treating sequences of digits as numbers. </p>
<p>compare_numeric - Compare strings, handle embedded numbers.</p>

</div>
</div>
<a class="anchor" id="a5e0af4ae481a5a88c250d936aa86325b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StringRef::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of non-overlapped occurrences of <code>Str</code> in the string. </p>
<p>count - Return the number of non-overlapped occurrences of</p>
<ul>
<li>Str in the string. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7d9b88d042ae1da8afd5509875c90a04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* llvm::StringRef::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>data - Get a pointer to the start of the string (which may not be null terminated). </p>

</div>
</div>
<a class="anchor" id="adb927d9c3777f22883b7a9e98dc20759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::drop_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a> equal to 'this' but with the last <code>N</code> elements dropped. </p>

</div>
</div>
<a class="anchor" id="a34ad0b412c2ed8e3c96befe511bdc1a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::drop_front </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classllvm_1_1StringRef.html" title="StringRef - Represent a constant reference to a string, i.e. ">StringRef</a> equal to 'this' but with the first <code>N</code> elements dropped. </p>

</div>
</div>
<a class="anchor" id="a29c565e0d52fdd3b366971d07fa0c83c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llvm::StringRef::equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equals - Check for string equality, this is more efficient than <a class="el" href="classllvm_1_1StringRef.html#aaad2ceb595181c43b5969814345ab198" title="compare - Compare two strings; the result is -1, 0, or 1 if this string is lexicographically less tha...">compare()</a> when the relative ordering of inequal strings isn't needed. </p>

</div>
</div>
<a class="anchor" id="a421e16456fe6d7b71fb4af736194165c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the first character <code>C</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a96985243e286d1d9c10028e7c2497c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StringRef::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the first string <code>Str</code> in the string. </p>
<p>find - Search for the first string</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first occurrence of <code>Str</code>, or npos if not found.</dd></dl>
<ul>
<li>Str in the string.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>- The index of the first occurrence of <ul>
<li>Str, or npos if not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ace8a9dc13034dc6a31a5dea627190c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first character in the string that is not <code>C</code> or npos if not found. </p>
<p>find_first_not_of - Find the first character in the string that is not</p>
<ul>
<li>C or npos if not found. </li>
</ul>

</div>
</div>
<a class="anchor" id="a777c832d1540b92bcff9c0570d161f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first character in the string that is not in the string <code>Chars</code>, or npos if not found. </p>
<p>find_first_not_of - Find the first character in the string that is not in the string</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<ul>
<li>Chars, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a class="anchor" id="a54b5863f31e0a39c204f3460f9ddde75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first character in the string that is <code>C</code>, or npos if not found. </p>
<p>Same as find. </p>

</div>
</div>
<a class="anchor" id="ae1b6861cb9a895bf41b8a4776d369223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first character in the string that is in <code>Chars</code>, or npos if not found. </p>
<p>find_first_of - Find the first character in the string that is in</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<ul>
<li>Chars, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a class="anchor" id="aebf350ba1b6968fc28d1d81173f7770f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the last character in the string that is not <code>C</code>, or npos if not found. </p>
<p>find_last_not_of - Find the last character in the string that is not</p>
<ul>
<li>C, or npos if not found. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad95913dd81e5003546d086043e4a5aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the last character in the string that is not in <code>Chars</code>, or npos if not found. </p>
<p>find_last_not_of - Find the last character in the string that is not in</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<ul>
<li>Chars, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a class="anchor" id="a0038321ed1d841fe288aee1277cadb70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::find_last_of </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the last character in the string that is <code>C</code>, or npos if not found. </p>

</div>
</div>
<a class="anchor" id="af5968a92ec57a8f6b7a68d177a647850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef::size_type StringRef::find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the last character in the string that is in <code>C</code>, or npos if not found. </p>
<p>find_last_of - Find the last character in the string that is in</p>
<p>Complexity: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size())</p>
<ul>
<li>C, or npos if not found.</li>
</ul>
<p>Note: O(<a class="el" href="classllvm_1_1StringRef.html#af68d5ebdb576d7481ea2766151b875d4" title="size - Get the string size. ">size()</a> + Chars.size()) </p>

</div>
</div>
<a class="anchor" id="a672503b088f3061a06a578586d3e0427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type llvm::StringRef::getAsInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>Result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current string as an integer of the specified radix. </p>
<p>If <code>Radix</code> is specified as zero, this does radix autosensing using extended C rules: 0 is octal, 0x is hex, 0b is binary.</p>
<p>If the string is invalid or if only a subset of the string is valid, this returns true to signify the error. The string is considered erroneous if empty or if it overflows T. </p>

</div>
</div>
<a class="anchor" id="a44b1141e695b117bb36a77961883893d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::ltrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return string with consecutive characters in <code>Chars</code> starting from the left removed. </p>

</div>
</div>
<a class="anchor" id="a87091ed60a621a3d430752da2996d27b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llvm::StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>From</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the last character <code>C</code> in the string. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>C</code>, or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a01bee3e5396e08d70d28f2273749ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StringRef::rfind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the last string <code>Str</code> in the string. </p>
<p>rfind - Search for the last string</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the last occurrence of <code>Str</code>, or npos if not found.</dd></dl>
<ul>
<li>Str in the string.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>- The index of the last occurrence of <ul>
<li>Str, or npos if not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a47513446cbacaec202fcad44e553e3c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classllvm_1_1StringRef.html">StringRef</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&gt; llvm::StringRef::rsplit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the last occurrence of a separator character. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is minimal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a class="anchor" id="a067bebe85de2211b84ee087cfc7c7694"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::rtrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return string with consecutive characters in <code>Chars</code> starting from the right removed. </p>

</div>
</div>
<a class="anchor" id="a84945a8050d1449eb630a7a1622aa76f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the substring from [Start, End). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">End</td><td>The index following the last character to include in the substring. If this is npos, or less than <code>Start</code>, or exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bcce769239a53df854d89c4e08d0b41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classllvm_1_1StringRef.html">StringRef</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&gt; llvm::StringRef::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator character. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>The character to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split substrings. </dd></dl>

</div>
</div>
<a class="anchor" id="af7e27b6de2b079de64e3e1808d5e35ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classllvm_1_1StringRef.html">StringRef</a>, <a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&gt; llvm::StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>
<p>If <code>Separator</code> is in the string, then the result is a pair (LHS, RHS) such that (*this == LHS + Separator + RHS) is true and RHS is maximal. If <code>Separator</code> is not in the string, then the result is a pair (LHS, RHS) where (*this == LHS) and (RHS == "").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The split substrings. </dd></dl>

</div>
</div>
<a class="anchor" id="aa754c526bdddebddbf5e27f067e9f07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StringRef::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1StringRef.html">StringRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxSplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>KeepEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split into substrings around the occurrences of a separator string. </p>
<p>Each substring is stored in <code>A</code>. If <code>MaxSplit</code> is &gt;= 0, at most <code>MaxSplit</code> splits are done and consequently &lt;= <code>MaxSplit</code> elements are added to A. If <code>KeepEmpty</code> is false, empty strings are not added to <code>A</code>. They still count when considering <code>MaxSplit</code> An useful invariant is that Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- Where to put the substrings. </td></tr>
    <tr><td class="paramname">Separator</td><td>- The string to split on. </td></tr>
    <tr><td class="paramname">MaxSplit</td><td>- The maximum number of times the string is split. </td></tr>
    <tr><td class="paramname">KeepEmpty</td><td>- True if empty substring should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d0712956e53687d1894ba17b84aeffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code>npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the substring from [Start, Start + N). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Start</td><td>The index of the starting character in the substring; if the index is npos or greater than the length of the string then the empty substring will be returned.</td></tr>
    <tr><td class="paramname">N</td><td>The number of characters to included in the substring. If N exceeds the number of characters remaining in the string, the string suffix (starting with <code>Start</code>) will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa20b9ae7228d48ceb497bd69f20a838f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a> llvm::StringRef::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a>&#160;</td>
          <td class="paramname"><em>Chars</em> = <code>&quot;&#160;\t\n\v\f\r&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return string with consecutive characters in <code>Chars</code> starting from the left and right removed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>build/ntSources/include/llvm/<a class="el" href="StringRef_8h_source.html">StringRef.h</a></li>
<li>build/ntSources/src/llvm/StringRef.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>llvm</b></li><li class="navelem"><a class="el" href="classllvm_1_1StringRef.html">StringRef</a></li>
    <li class="footer">Generated on Fri Jan 15 2016 14:22:10 for WPILibC++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>

<!-- Mirrored from first.wpi.edu/FRC/roborio/release/docs/cpp/classllvm_1_1StringRef.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 22 Jan 2016 07:54:36 GMT -->
</html>
